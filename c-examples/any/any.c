/*
 *    any.c
 *
 *    "ANY-TEST" ASN.1 module encode/decode/print/free C src.
 *
 *    This file was generated by snacc on Wed Oct 23 09:29:42 2002
 *
 *    UBC snacc written by Mike Sample
 *
 *    NOTE: This is a machine generated file - editing not recommended
 */


#include "any.h"


AsnInt intId = 1;

AsnInt boolId = 2;

AsnInt octsId = 3;

AsnInt bitsId = 4;

AsnInt realId = 5;

AsnOid intOid = { 5, "\1\2\3\4\1" };

AsnOid boolOid = { 5, "\1\2\3\4\2" };

AsnOid octsOid = { 5, "\1\2\3\4\3" };

AsnOid bitsOid = { 5, "\1\2\3\4\4" };

AsnOid realOid = { 5, "\1\2\3\4\5" };

void
InitAnyANY_TEST()
{
    AsnOid oid0 ={ 5, "\1\2\3\4\1" };
    AsnOid oid1 ={ 5, "\1\2\3\4\2" };
    AsnOid oid2 ={ 5, "\1\2\3\4\3" };
    AsnOid oid3 ={ 5, "\1\2\3\4\4" };
    AsnOid oid4 ={ 5, "\1\2\3\4\5" };


    InstallAnyByInt (intId_ANY_ID, 1, sizeof (AsnInt), (EncodeFcn)BEncAsnInt, (DecodeFcn)BDecAsnInt, (FreeFcn)NULL, (PrintFcn)PrintAsnInt);

    InstallAnyByInt (boolId_ANY_ID, 2, sizeof (AsnBool), (EncodeFcn)BEncAsnBool, (DecodeFcn)BDecAsnBool, (FreeFcn)NULL, (PrintFcn)PrintAsnBool);

    InstallAnyByInt (octsId_ANY_ID, 3, sizeof (OctsId), (EncodeFcn)BEncOctsId, (DecodeFcn)BDecOctsId, (FreeFcn)FreeOctsId, (PrintFcn)PrintOctsId);

    InstallAnyByInt (bitsId_ANY_ID, 4, sizeof (BitsId), (EncodeFcn)BEncBitsId, (DecodeFcn)BDecBitsId, (FreeFcn)FreeBitsId, (PrintFcn)PrintBitsId);

    InstallAnyByInt (realId_ANY_ID, 5, sizeof (AsnReal), (EncodeFcn)BEncAsnReal, (DecodeFcn)BDecAsnReal, (FreeFcn)NULL, (PrintFcn)PrintAsnReal);

    InstallAnyByOid (intOid_ANY_ID, &oid0, sizeof (AsnInt), (EncodeFcn)BEncAsnInt, (DecodeFcn)BDecAsnInt, (FreeFcn)NULL, (PrintFcn)PrintAsnInt);

    InstallAnyByOid (boolOid_ANY_ID, &oid1, sizeof (AsnBool), (EncodeFcn)BEncAsnBool, (DecodeFcn)BDecAsnBool, (FreeFcn)NULL, (PrintFcn)PrintAsnBool);

    InstallAnyByOid (octsOid_ANY_ID, &oid2, sizeof (AsnOcts), (EncodeFcn)BEncAsnOcts, (DecodeFcn)BDecAsnOcts, (FreeFcn)FreeAsnOcts, (PrintFcn)PrintAsnOcts);

    InstallAnyByOid (bitsOid_ANY_ID, &oid3, sizeof (AsnBits), (EncodeFcn)BEncAsnBits, (DecodeFcn)BDecAsnBits, (FreeFcn)FreeAsnBits, (PrintFcn)PrintAsnBits);

    InstallAnyByOid (realOid_ANY_ID, &oid4, sizeof (AsnReal), (EncodeFcn)BEncAsnReal, (DecodeFcn)BDecAsnReal, (FreeFcn)NULL, (PrintFcn)PrintAsnReal);

}  /* InitAnyANY_TEST */


AsnLen BEncBitsId PARAMS ((b, v),
GenBuf * b _AND_
BitsId *v)
{
    AsnLen l=0;
    BEncEocIfNec (b);
    l = BEncBitsIdContent (b, v);
    l += BEncDefLen (b, l);
    l += BEncTag1 (b, UNIV, PRIM, BITSTRING_TAG_CODE);
    l += BEncConsLen (b, l);
    l += BEncTag1 (b, PRIV, CONS, 1);
    return l;
} /* BEncBitsId */

void BDecBitsId PARAMS ((b, result, bytesDecoded, env),
GenBuf * b _AND_
BitsId *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;
    AsnLen elmtLen2;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (PRIV, CONS, 1)))
    {
        Asn1Error ("BDecBitsId: ERROR - wrong tag\n");
        longjmp (env, -100);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE))&&
         (tag != MAKE_TAG_ID (UNIV, CONS, BITSTRING_TAG_CODE)))
    {
        Asn1Error ("BDecBitsId: ERROR - wrong tag\n");
        longjmp (env, -101);
    }
    elmtLen2 = BDecLen (b, bytesDecoded, env);
    BDecBitsIdContent (b, tag, elmtLen2, result, bytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
}  /* BDecBitsId */

AsnLen BEncOctsId PARAMS ((b, v),
GenBuf * b _AND_
OctsId *v)
{
    AsnLen l=0;
    l = BEncOctsIdContent (b, v);
    l += BEncDefLen (b, l);
    l += BEncTag1 (b, PRIV, PRIM, 2);
    return l;
} /* BEncOctsId */

void BDecOctsId PARAMS ((b, result, bytesDecoded, env),
GenBuf * b _AND_
OctsId *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (PRIV, PRIM, 2))&&
        (tag != MAKE_TAG_ID (PRIV, CONS, 2)))
    {
        Asn1Error ("BDecOctsId: ERROR - wrong tag\n");
        longjmp (env, -102);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    BDecOctsIdContent (b, tag, elmtLen1, result, bytesDecoded, env);
}  /* BDecOctsId */

AsnLen
BEncAttrValue1Content PARAMS ((b, v),
GenBuf * b _AND_
AttrValue1 *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    SetAnyTypeByInt ((&v->anyDefBy), (v->id));
    itemLen = BEncAsnAnyDefinedBy (b, (&v->anyDefBy));

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->id));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAttrValue1Content */

void
BDecAttrValue1Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AttrValue1 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->id), &totalElmtsLen1, env);
    }
    else
        longjmp (env, -103);


    {
    SetAnyTypeByInt ((&v->anyDefBy), (v->id));
    BDecAsnAnyDefinedBy (b, (&v->anyDefBy), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -104);
    }


    if (!seqDone)
        longjmp (env, -105);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAttrValue1Content */

void
PrintAttrValue1 PARAMS ((f, v, indent),
FILE* f _AND_
AttrValue1 *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, (unsigned short)(indent + stdIndentG));
    fprintf (f,"id ");
    PrintAsnInt (f, (&v->id), (unsigned short)(indent + stdIndentG));
    fprintf (f, ",\n");
    Indent (f, (unsigned short)(indent + stdIndentG));
    PrintAsnAnyDefinedBy (f, (&v->anyDefBy), (unsigned short)(indent + stdIndentG));
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAttrValue1 */

void
FreeAttrValue1 PARAMS ((v),
AttrValue1 *v)
{

    if (v == NULL)
        return;
    FreeAsnInt ((&v->id));

    FreeAsnAnyDefinedBy ((&v->anyDefBy));

}  /* FreeAttrValue1 */




AsnLen
BEncAttrValue2Content PARAMS ((b, v),
GenBuf * b _AND_
AttrValue2 *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    SetAnyTypeByOid ((&v->anyDefBy), (&v->id));
    itemLen = BEncAsnAnyDefinedBy (b, (&v->anyDefBy));

    totalLen += itemLen;

    itemLen = BEncAsnOidContent (b, (&v->id));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, OID_TAG_CODE);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAttrValue2Content */

void
BDecAttrValue2Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AttrValue2 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnOidContent (b, tagId1, elmtLen1, (&v->id), &totalElmtsLen1, env);
    }
    else
        longjmp (env, -106);


    {
    SetAnyTypeByOid ((&v->anyDefBy), (&v->id));
    BDecAsnAnyDefinedBy (b, (&v->anyDefBy), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -107);
    }


    if (!seqDone)
        longjmp (env, -108);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAttrValue2Content */

void
PrintAttrValue2 PARAMS ((f, v, indent),
FILE* f _AND_
AttrValue2 *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, (unsigned short)(indent + stdIndentG));
    fprintf (f,"id ");
    PrintAsnOid (f, (&v->id), (unsigned short)(indent + stdIndentG));
    fprintf (f, ",\n");
    Indent (f, (unsigned short)(indent + stdIndentG));
    PrintAsnAnyDefinedBy (f, (&v->anyDefBy), (unsigned short)(indent + stdIndentG));
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAttrValue2 */

void
FreeAttrValue2 PARAMS ((v),
AttrValue2 *v)
{

    if (v == NULL)
        return;
    FreeAsnOid ((&v->id));

    FreeAsnAnyDefinedBy ((&v->anyDefBy));

}  /* FreeAttrValue2 */




AsnLen
BEncTSeq1Content PARAMS ((b, v),
GenBuf * b _AND_
TSeq1 *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncAttrValue1Content (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTSeq1Content */

void
BDecTSeq1Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TSeq1 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        AttrValue1 **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (AttrValue1**) AsnListAppend (v);
    (*tmpVar) = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecAttrValue1Content (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -109);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTSeq1Content */

void
PrintTSeq1 PARAMS ((f, v, indent),
FILE* f _AND_
TSeq1 *v _AND_
unsigned short int indent)
{
    AttrValue1 *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, (unsigned short)(indent+ stdIndentG));
        PrintAttrValue1 (f, tmp, (unsigned short)(indent + stdIndentG));
        if (tmp != (AttrValue1*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTSeq1 */

void
FreeTSeq1 PARAMS ((v),
TSeq1 *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeAttrValue1 ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTSeq1 */




AsnLen
BEncTSeq2Content PARAMS ((b, v),
GenBuf * b _AND_
TSeq2 *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncAttrValue2Content (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTSeq2Content */

void
BDecTSeq2Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TSeq2 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        AttrValue2 **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (AttrValue2**) AsnListAppend (v);
    (*tmpVar) = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecAttrValue2Content (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -110);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTSeq2Content */

void
PrintTSeq2 PARAMS ((f, v, indent),
FILE* f _AND_
TSeq2 *v _AND_
unsigned short int indent)
{
    AttrValue2 *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, (unsigned short)(indent+ stdIndentG));
        PrintAttrValue2 (f, tmp, (unsigned short)(indent + stdIndentG));
        if (tmp != (AttrValue2*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTSeq2 */

void
FreeTSeq2 PARAMS ((v),
TSeq2 *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeAttrValue2 ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTSeq2 */




AsnLen BEncAnyTestType PARAMS ((b, v),
GenBuf * b _AND_
AnyTestType *v)
{
    AsnLen l=0;
    BEncEocIfNec (b);
    l = BEncAnyTestTypeContent (b, v);
    l += BEncConsLen (b, l);
    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    return l;
} /* BEncAnyTestType */

void BDecAnyTestType PARAMS ((b, result, bytesDecoded, env),
GenBuf * b _AND_
AnyTestType *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        Asn1Error ("BDecAnyTestType: ERROR - wrong tag\n");
        longjmp (env, -111);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    BDecAnyTestTypeContent (b, tag, elmtLen1, result, bytesDecoded, env);
}  /* BDecAnyTestType */

AsnLen
BEncAnyTestTypeContent PARAMS ((b, v),
GenBuf * b _AND_
AnyTestType *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncTSeq2Content (b, (v->oidMap));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncTSeq1Content (b, (v->intMap));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAnyTestTypeContent */

void
BDecAnyTestTypeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AnyTestType *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->intMap) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->intMap), env);
    BDecTSeq1Content (b, tagId1, elmtLen1, (v->intMap), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -112);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->oidMap) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->oidMap), env);
    BDecTSeq2Content (b, tagId1, elmtLen1, (v->oidMap), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -113);
    }
    else
        longjmp (env, -114);


    if (!seqDone)
        longjmp (env, -115);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAnyTestTypeContent */

void
PrintAnyTestType PARAMS ((f, v, indent),
FILE* f _AND_
AnyTestType *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, (unsigned short)(indent + stdIndentG));
    fprintf (f,"intMap ");
    PrintTSeq1 (f, (v->intMap), (unsigned short)(indent + stdIndentG));
    fprintf (f, ",\n");
    Indent (f, (unsigned short)(indent + stdIndentG));
    fprintf (f,"oidMap ");
    PrintTSeq2 (f, (v->oidMap), (unsigned short)(indent + stdIndentG));
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAnyTestType */

void
FreeAnyTestType PARAMS ((v),
AnyTestType *v)
{

    if (v == NULL)
        return;
    FreeTSeq1 ((v->intMap));
    Asn1Free ((v->intMap));

    FreeTSeq2 ((v->oidMap));
    Asn1Free ((v->oidMap));

}  /* FreeAnyTestType */




