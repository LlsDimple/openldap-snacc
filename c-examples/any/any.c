/*
 *    any.c
 *    "ANY-TEST" ASN.1 module encode/decode/print/free C src.
 *    This file was generated by Coral WinSnacc on Thu Oct  7 09:01:53 2004
 *    Coral WinSnacc written by Deepak Gupta
 *    NOTE: This is a machine generated file - editing not recommended
 */

#include "any.h"


void InitAnyANY_TEST()
{
    AsnOid oid0 ={ 5, "\1\2\3\4\1" };
    AsnOid oid1 ={ 5, "\1\2\3\4\2" };
    AsnOid oid2 ={ 5, "\1\2\3\4\3" };
    AsnOid oid3 ={ 5, "\1\2\3\4\4" };
    AsnOid oid4 ={ 5, "\1\2\3\4\5" };


    InstallAnyByInt (intId_ANY_ID, 1, sizeof (AsnInt), (EncodeFcn)BEncAsnInt, (DecodeFcn)BDecAsnInt, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByInt (boolId_ANY_ID, 2, sizeof (AsnBool), (EncodeFcn)BEncAsnBool, (DecodeFcn)BDecAsnBool, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByInt (octsId_ANY_ID, 3, sizeof (OctsId), (EncodeFcn)BEncOctsId, (DecodeFcn)BDecOctsId, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByInt (bitsId_ANY_ID, 4, sizeof (BitsId), (EncodeFcn)BEncBitsId, (DecodeFcn)BDecBitsId, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByInt (realId_ANY_ID, 5, sizeof (AsnReal), (EncodeFcn)BEncAsnReal, (DecodeFcn)BDecAsnReal, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByOid (intOid_ANY_ID, &oid0, sizeof (AsnInt), (EncodeFcn)BEncAsnInt, (DecodeFcn)BDecAsnInt, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByOid (boolOid_ANY_ID, &oid1, sizeof (AsnBool), (EncodeFcn)BEncAsnBool, (DecodeFcn)BDecAsnBool, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByOid (octsOid_ANY_ID, &oid2, sizeof (AsnOcts), (EncodeFcn)BEncAsnOcts, (DecodeFcn)BDecAsnOcts, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByOid (bitsOid_ANY_ID, &oid3, sizeof (AsnBits), (EncodeFcn)BEncAsnBits, (DecodeFcn)BDecAsnBits, (FreeFcn)NULL, (PrintFcn)NULL);

    InstallAnyByOid (realOid_ANY_ID, &oid4, sizeof (AsnReal), (EncodeFcn)BEncAsnReal, (DecodeFcn)BDecAsnReal, (FreeFcn)NULL, (PrintFcn)NULL);

}  /* InitAnyANY_TEST */


void BDecBitsId PARAMS ((b, result, bytesDecoded, env),
GenBuf * b _AND_
BitsId *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;
    AsnLen elmtLen2;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (PRIV, CONS, 1)))
    {
        Asn1Error ("BDecBitsId: ERROR - wrong tag\n");
        longjmp (env, -100);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE))&&
         (tag != MAKE_TAG_ID (UNIV, CONS, BITSTRING_TAG_CODE)))
    {
        Asn1Error ("BDecBitsId: ERROR - wrong tag\n");
        longjmp (env, -101);
    }
    elmtLen2 = BDecLen (b, bytesDecoded, env);
    BDecBitsIdContent (b, tag, elmtLen2, result, bytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, bytesDecoded, env);
}  /* BDecBitsId */

void BDecOctsId PARAMS ((b, result, bytesDecoded, env),
GenBuf * b _AND_
OctsId *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (PRIV, PRIM, 2))&&
        (tag != MAKE_TAG_ID (PRIV, CONS, 2)))
    {
        Asn1Error ("BDecOctsId: ERROR - wrong tag\n");
        longjmp (env, -102);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    BDecOctsIdContent (b, tag, elmtLen1, result, bytesDecoded, env);
}  /* BDecOctsId */

void
BDecAttrValue1Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AttrValue1 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->id), &totalElmtsLen1, env);
    }
    else
        longjmp (env, -103);


    {
    SetAnyTypeByInt ((&v->anyDefBy), (v->id));
    BDecAsnAnyDefinedBy (b, (&v->anyDefBy), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -104);
    }


    if (!seqDone)
        longjmp (env, -105);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAttrValue1*/


void
BDecAttrValue2Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AttrValue2 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnOidContent (b, tagId1, elmtLen1, (&v->id), &totalElmtsLen1, env);
    }
    else
        longjmp (env, -106);


    {
    SetAnyTypeByOid ((&v->anyDefBy), (&v->id));
    BDecAsnAnyDefinedBy (b, (&v->anyDefBy), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -107);
    }


    if (!seqDone)
        longjmp (env, -108);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAttrValue2*/


void
BDecTSeq1Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TSeq1 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        AttrValue1 **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (AttrValue1**) AsnListAppend (Componentv);
    (*tmpVar) = (AttrValue1*) Asn1Alloc (sizeof (AttrValue1));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecAttrValue1Content (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -109);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTSeq1Content */


void
BDecTSeq2Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TSeq2 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        AttrValue2 **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (AttrValue2**) AsnListAppend (Componentv);
    (*tmpVar) = (AttrValue2*) Asn1Alloc (sizeof (AttrValue2));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecAttrValue2Content (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -110);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTSeq2Content */


void BDecAnyTestType PARAMS ((b, result, bytesDecoded, env),
GenBuf * b _AND_
AnyTestType *result _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    AsnTag tag;
    AsnLen elmtLen1;

    if (((tag = BDecTag (b, bytesDecoded, env)) != 
MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        Asn1Error ("BDecAnyTestType: ERROR - wrong tag\n");
        longjmp (env, -111);
    }
    elmtLen1 = BDecLen (b, bytesDecoded, env);
    BDecAnyTestTypeContent (b, tag, elmtLen1, result, bytesDecoded, env);
}  /* BDecAnyTestType */

void
BDecAnyTestTypeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AnyTestType *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
	(v->intMap) = AsnListNew(sizeof(char*));
    BDecTSeq1Content (b, tagId1, elmtLen1, (v->intMap), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -112);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
	(v->oidMap) = AsnListNew(sizeof(char*));
    BDecTSeq2Content (b, tagId1, elmtLen1, (v->oidMap), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -113);
    }
    else
        longjmp (env, -114);


    if (!seqDone)
        longjmp (env, -115);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAnyTestType*/


